*   What are the differences between Unit Testing, Functional Testing and Integration Testing.

>>  (1) Unit Testing:

        - Testing individual units/pieces of code in isolation, typically one method or function at a time.

        Example:

            - Suppose a class has a saveUser() method.

            - In Unit Testing, you check if that method functions properly.

    (2) Functional Testing:

        - Testing the functionality of a system from the user's point of view, ensuring that the functionality behaves 
          according to the requirements.

        Example:

            - Suppose there's a login functionality which performs multiple operation behind.

            - In Functional Testing, you would check if login functionality works properly or not.
    
    (3) Integration Testing:

        - Testing multiple components, modules, or systems together after they are integrated, to 
          ensure they interact and function correctly as a group.
        
        Example:

            - Suppose there's a module A for User Registration and module B for Email Notification Service.

            - In Integration Testing, you check after a user registers, an email is actually sent.

________________________________________________________________________________________________________________________

*   What is Test-Driven Development (TDD) ?

>>  TDD is a software development approach where developers write test cases first for a new feature or functionality 
    before writing the actual code. 
    
    The development process follows a short, repetitive TDD cycle also called "Red-Green-Refactor": 
    
        (1) Red: 
        
            - Write a test for the new functionality; it fails (since the feature isn't built yet).
        
        (2) Green: 
        
            - Write just enough code to make the test pass.
        
        (3) Refactor: 
        
            - Improve the code's structure and design without changing its behavior, while ensuring the test still passes.

    Key Benefits:

        - Ensures better code quality and design.

        - Helps in early bug detection.

        - Encourages smaller, modular, and loosely-coupled code units.

    Example:

        - You want to build an add(int a, int b) method.

        (1) First, write a test:

            ```
                @Test
                void testAddition() {
                    Calculator calc = new Calculator();
                    assertEquals(5, calc.add(2, 3));
                }
            ```

        (2) Run the test: 
        
            - It will fail as method not implemented yet.

        (3) Implement the minimal working code:

            ```
                int add(int a, int b) {
                    return a + b;
                }
            ```

        (4) Test passes.

        (5) Refactor if needed (e.g., improve naming, handle edge cases).

________________________________________________________________________________________________________________________

*   What is the difference between manual testing and unit testing ?

>>  Manual Testing is the process of testing software by human testers without using any automated tools or scripts where 
    testers execute test cases manually to find defects 
    
    Unit Testing involves testing individual units or components of code (like methods or functions) automatically, 
    typically using a unit testing framework (e.g., JUnit for Java).

________________________________________________________________________________________________________________________

*   What is JUnit ? Why do we use it ?

>>  JUnit is a popular testing framework for Java, primarily used to perform unit testing of individual components 
    (like classes and methods) to ensure code correctness and catch bugs early during development.

    It provides annotations, assertions, and tools to write, execute, and organize test cases efficiently. 

    Why use it:

        - Automates repetitive testing tasks.

        - Supports Test-Driven Development (TDD) practices.

    Example:

        ```
            import org.junit.jupiter.api.Test;
            import static org.junit.jupiter.api.Assertions.assertEquals;

            class CalculatorTest {

                @Test
                void testAddition() {

                    Calculator calc = new Calculator();
                    assertEquals(5, calc.add(2, 3));
                }
            }
        ```

________________________________________________________________________________________________________________________

*   What are the benefits of using unit testing frameworks like JUnit ?

>>  (1) Automation:
        
        - Quickly run thousands of test cases automatically without manual intervention.

    (2) Supports Test-Driven Development (TDD):

        - Encourages writing tests first and building code around them, leading to better-designed software.

    (3) Integration with Build Tools:
        
        - Easily integrates with tools like Maven, Jenkins etc for continuous testing during builds and deployments.

    (4) Detailed Reporting:
        
        - Provides clear reports on which tests passed or failed, helping in faster debugging.

________________________________________________________________________________________________________________________

*   Explain the lifecycle of a JUnit test case.

>>  The lifecycle of a JUnit test case refers to the sequence of events that occur from the start to the end of a test 
    methodâ€™s execution. 
    
    It includes initializing the test environment, running the test, and cleaning up after the test finishes. 
    
    Lifecycle Phases (in JUnit 5):
        
        (1) Before Test Execution:

            (a) @BeforeAll: 
            
                - Runs once before all test methods in the class. Typically used for expensive setup tasks 
                  (e.g., database connections).

            (b) @BeforeEach: 
            
                - Runs before each test method. Used to set up the test environment (e.g., initializing variables).

        (2) Test Method Execution:

            - The test method itself is executed, and assertions are made to validate the expected behavior.

        (3) After Test Execution:

            (a) @AfterEach: 
            
                - Runs after each test method. Used for cleanup tasks (e.g., resetting values, closing files).

            (b) @AfterAll: 
            
                - Runs once after all test methods in the class. Typically used for global cleanup tasks 
                  (e.g., closing database connections).

        (4) Test Result:

            - The test either passes (assertions are true) or fails (assertions are false).

    Example:

        ```
            class MyTest {

                @BeforeAll
                static void setupAll() {
                    System.out.println("Running before all tests");
                }

                @BeforeEach
                void setup() {
                    System.out.println("Running before each test");
                }

                @Test
                void testMethod1() {
                    System.out.println("Executing testMethod1");
                    Assertions.assertTrue(true);
                }

                @Test
                void testMethod2() {
                    System.out.println("Executing testMethod2");
                    Assertions.assertTrue(true);
                }

                @AfterEach
                void cleanup() {
                    System.out.println("Running after each test");
                }

                @AfterAll
                static void cleanupAll() {
                    System.out.println("Running after all tests");
                }
            }
        ```
        
        Output:

            ```
                Running before all tests
                Running before each test
                Executing testMethod1
                Running after each test
                Running before each test
                Executing testMethod2
                Running after each test
                Running after all tests
            ```

________________________________________________________________________________________________________________________

*   How do you write a basic Test Case in JUnit ?

>>  Steps to write a basic JUnit Test Case:
        
        (1) Create a test class:
            
            - Annotate the class with @Test to indicate it contains test methods.

        (2) Write a test method:
            
            - Each test case should be a method annotated with @Test. Inside the method, you call the code to be 
              tested and use assertions to verify the result.

        (3) Use assertions:
            
            - Assertions compare the expected output with the actual output (e.g., assertEquals, assertTrue, etc.).

    Example:

        ```
            import org.junit.jupiter.api.Test;
            import static org.junit.jupiter.api.Assertions.assertEquals;

            class CalculatorTest {

                @Test
                void testAddition() {
                    Calculator calc = new Calculator();
                    int result = calc.add(2, 3);  // Method being tested
                    assertEquals(5, result);      // Assertion to verify result
                }
            }
        ```

________________________________________________________________________________________________________________________










*   What are assertions in JUnit ? Give examples.

>>

________________________________________________________________________________________________________________________

*   Explain the difference between assertEquals() and assertSame().

>>

________________________________________________________________________________________________________________________

*   What is assertTrue() and assertFalse() used for?

>>

________________________________________________________________________________________________________________________

*   How do you test exceptions in JUnit 4 and JUnit 5 ?

>>

________________________________________________________________________________________________________________________

*   How do you group multiple assertions together (JUnit 5's assertAll) ?

>>

________________________________________________________________________________________________________________________

*   Explain the difference between assertThrows and ExpectedException rule.

>>

________________________________________________________________________________________________________________________

*   What is assertTimeout() used for in JUnit 5 ?

>>

________________________________________________________________________________________________________________________

*   How to integrate Junit in Spring Application ?

>>  Steps to integrate JUnit in a Spring Application:
        
        (1) Add Dependencies: 
        
            - Include the necessary dependencies for JUnit and Spring Test in your pom.xml.

            ```
                <dependency>
                    <groupId>org.junit.jupiter</groupId>
                    <artifactId>junit-jupiter-api</artifactId>
                    <scope>test</scope>
                </dependency>
                <dependency>
                    <groupId>org.junit.jupiter</groupId>
                    <artifactId>junit-jupiter-engine</artifactId>
                    <scope>test</scope>
                </dependency>
                
                <!-- Spring Test Context -->
                <dependency>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-test</artifactId>
                    <scope>test</scope>
                </dependency>
            ```

        (2) Create Test Class: 
        
            - In your test class, use annotations like @ExtendWith(SpringExtension.class) to enable Spring support in JUnit 5.

        (3) Load Spring Context: 
        
            - Use the @SpringBootTest or @ContextConfiguration annotations to load the Spring application context for 
              integration tests.

        (4) Autowired Components: 
        
            - You can @Autowired Spring beans (e.g., services, repositories) into your test class to test them.

    Example:
        
        ```
            import org.junit.jupiter.api.Test;
            import org.junit.jupiter.api.extension.ExtendWith;
            import org.springframework.beans.factory.annotation.Autowired;
            import org.springframework.boot.test.context.SpringBootTest;
            import static org.junit.jupiter.api.Assertions.assertEquals;

            @SpringBootTest
            @ExtendWith(SpringExtension.class)
            class CalculatorServiceTest {

                @Autowired
                private CalculatorService calculatorService;  // Injecting Spring bean

                @Test
                void testAddition() {
                    int result = calculatorService.add(2, 3);
                    assertEquals(5, result);
                }
            }
        ```
        
________________________________________________________________________________________________________________________

*   How to execute Junit Test Cases in Spring Application ?

>>

________________________________________________________________________________________________________________________
















What is parameterized testing ? How to implement it in JUnit 5 ?

How do you test private methods in JUnit?

How do you ignore a test in JUnit 4 vs JUnit 5?

How do you run multiple test classes together?

Explain the use of DynamicTest in JUnit 5.

How is JUnit 5 architecture different from JUnit 4?

Explain the role of the TestEngine in JUnit 5.

How do you integrate JUnit with Maven?

How do you use JUnit with Mockito for mocking?

How do you run JUnit tests automatically during a Maven build?

What is the role of the Surefire plugin in Maven related to JUnit tests?

Can you run JUnit tests in parallel ? How?

What is test coverage and how do you measure it with JUnit ?

How do you integrate JUnit tests with a CI/CD pipeline (e.g., Jenkins)?

What are best practices for writing good JUnit tests ?

What should you avoid when writing unit tests ?

What is mocking, and when should you mock in unit tests ?

What is stubbing in unit testing ?

How would you structure a JUnit test class? (AAA Pattern: Arrange, Act, Assert)

Why are some tests failing only sometimes (flaky tests) ? How to fix them ?

What to do if a test case depends on system time ?

What happens if a test method throws an unexpected exception ?

How do you deal with database interactions in JUnit tests ?

How do you handle multi-threading scenarios in JUnit tests ?

How does JUnit support TDD ?

Why is isolation important in unit testing ?

Can we use JUnit for performance testing ? If yes, how ?